租约分为leader租约和follower租约


### leader租约
- leader租约与election_timeout_ms时间一致
- 当选为leader后或者transfer leader到其它节点失败会执行on_leader_start，该函数自增leader租约的epoch以及设置term，但last_active_timestamp仍然为0，此时的leader租约状态为NOT_READY
- 当leader step_down到follower状态或者transfer leader到其它节点则leader租约执行on_leader_stop重置
- 当选为leader后会将当前Configuration写到raft log中，apply成功则调用leader租约的on_lease_start设置last_active_timestamp, 在last_active_timestamp+election_timeout_ms时间内租约是VALID状态，表示leader的数据是最新的，此时用户从leader中读取数据是线性读
- leader的last_active_timestamp是按照follower的last_rpc_send_timestamp从小到大排序后取1/2处的时间，表示leader的租约跟一半节点的last_rpc_send_timestamp一致
- leader租约不会定时更新，是用户调用get_leader_lease_status函数时如果发现leader租约处于SUSPECT状态(当前时间大于last_active_timestamp+election_timeout_ms)，则会重新设置leader租约，即按需更新leader租约


### follower租约
- follower lease = election_timeout_ms + max_clock_drift_ms，max_clock_drift_ms表示时钟漂移时间，follower租约时间要大于leader租约时间，这里假设follower租约过期则也会超过leader的租约期，不会在leader租约过期前选举出一个新leader
- follower收到leader的append_entry则会更新last_leader_timestamp为当前时间
- 本节点变成leader后会将follower leader重置
- 如果follower收到了vote request且vote request中的disrupted_leader和本节点的leader id相同，则将follower租约设置为0立刻过期，这样可以让本节点也尽快发起投票
- 只有election_timer超时以及follower租约过期后才会发起pre_vote，如果是用户手动发起的vote，虽然follower租约没有过期向其它节点发起了投票，则需要等follower leaser过期后才能为自己投票，除非leader给自己投票，则可以放心的给自己投票
