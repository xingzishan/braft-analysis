follower在一定时间内未收到leader心跳，就会发起选举，一般先发起preVote，过半节点投票后再发起Vote，类似两阶段提交。

## Node启动
Node通过init函数初始化启动，init函数主要工作如下：
- 初始化timer
- 设置apply queue
- 初始化leader lease和follower lease
- 初始化log和log manager，log_manager可以获取到last_log_id
- 初始化ballox box，用于投票统计以及设置commit index
- 初始化snapshot storage
- 初始化conf，包含peer列表，如果有log，则从log中初始化conf，否则从options中的initial_conf初始化
- 初始化meta storage，用于初始化current_term和voted_id
- 初始化replicator_group，用于日志复制
- 设置初始状态为follower

如果current_term为1以及voted_id为空，说明是第一次启动，将follower lease重置，后续发起preVote可以直接发起，不需要等follower lease过期。
如果conf不为空(正常情况下也不为空)，则执行**step_down**函数，该函数会启动选举定时器(election_timer)，后续会介绍step_down函数
如果conf中只包含自己一个node，则该node应该为leader，跳过preVote阶段执行elect_self函数直接发起投票

#### step_down
该函数主要作用就是启动election_timer，为preVote做准备，启动election_timer之前会将vote_timer停掉，并将leader设置为空。
```
if (_state == STATE_CANDIDATE) {
    _vote_timer.stop();
    _vote_ctx.reset(this);
}
clear_append_entries_cache();
reset_leader_id(empty_id, status);
_election_timer.start();
```

#### 心跳超时引起的选举
如果follower在election_timeout_ms时间后会触发election_timer超时执行handle_election_timeout，该函数判断不在vote阶段以及follower租约过期后，会将leader设置为空，并发起preVote。需注意的是不管是刚启动的节点还是运行中的节点，如果follower在election_timeout_ms内收到了leader的心跳，则会更新follower lease，在执行handle_election_timeout函数时会因为follower lease未过期而无法发起preVote。

```
  // Trigger vote manually, or wait until follower lease expire.
  if (!_vote_triggered && !_follower_lease.expired()) {
      return;
  }

  // Reset leader as the leader is uncerntain on election timeout.
  PeerId empty_id;
  butil::Status status;
  status.set_error(ERAFTTIMEDOUT, "Lost connection from leader %s",
                   _leader_id.to_string().c_str());
  reset_leader_id(empty_id, status);

  return pre_vote(&lck, triggered);
```
